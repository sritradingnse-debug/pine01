//@version=6
indicator(title="Trade Orders Visualizer", shorttitle="OrdersPL", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ============================================
// TRADE ORDERS VISUALIZER
// ============================================
// Paste your CSV trade data in the input field below
// Expected CSV format: symbol,trade_type,quantity,price,order_execution_time
// Example: NIFTY25NOVFUT,buy,75,26167,2025-11-21T09:23:22
// ============================================

// Input for CSV data
ordersData = input.text_area(defval="\"Time\",\"Type\",\"Instrument\",\"Product\",\"Qty.\",\"Avg. price\",\"Status\",\"\"\n\"2025-11-24 15:05:14\",\"BUY\",\"NIFTY25NOV25800CE\",\"NRML\",\"525/525\",212.91,\"COMPLETE\",\"\"\n\"2025-11-24 15:04:45\",\"SELL\",\"NIFTY25NOV25800CE\",\"NRML\",\"525/525\",222.21,\"COMPLETE\",\"\"\n\"2025-11-24 15:02:54\",\"BUY\",\"NIFTY25NOV25800CE\",\"NRML\",\"525/525\",244.35,\"COMPLETE\",\"\"", title="Trade Orders CSV Data (New Format)", group="Data Input")

// Display settings
showBuyOrders = input(true, "Show Buy Orders", group="Display")
showSellOrders = input(true, "Show Sell Orders", group="Display")
buyColor = input(color.new(color.green, 20), "Buy Order Color", group="Display")
sellColor = input(color.new(color.red, 20), "Sell Order Color", group="Display")
textColorBuy = input(color.green, "Buy Text Color", group="Display")
textColorSell = input(color.red, "Sell Text Color", group="Display")
orderSize = input.string("small", "Label Size", options=["tiny", "small", "normal"], group="Display")
matchSymbol = input(false, "Match Current Symbol", tooltip="Only show orders for the current chart symbol", group="Display")

// Global cache storage for parsed orders (initialized once)
var array<int> cachedOrderTimes = array.new<int>()
var array<string> cachedOrderSymbols = array.new<string>()
var array<string> cachedOrderTypes = array.new<string>()
var array<float> cachedOrderQuantities = array.new<float>()
var array<float> cachedOrderPrices = array.new<float>()
var bool cacheInitialized = false

// Stack to track open positions (FIFO matching)
var array<string> positionStack = array.new<string>()  // Format: "type|qty|price"
var float globalRunningPL = 0.0  // Global cumulative P&L

// Calculate P&L by matching orders with stack (FIFO)
f_calculatePLWithStack(orderType, quantity, price, posStack) =>
    realizedPL = 0.0
    remainingQty = quantity
    stackSize = array.size(posStack)
    
    log.info("Processing " + orderType + ": " + str.tostring(quantity, "0") + "@" + str.tostring(price, "#.##") + " | Stack size before: " + str.tostring(stackSize))
    
    if orderType == "buy"
        // Try to match with open SHORT positions
        i = 0
        while remainingQty > 0 and i < array.size(posStack)
            topPos = array.get(posStack, i)
            posType = str.substring(topPos, 0, str.pos(topPos, "|"))
            
            if posType == "sell"
                parts = str.split(topPos, "|")
                posQty = str.tonumber(array.get(parts, 1))
                posPrice = str.tonumber(array.get(parts, 2))
                
                if posQty > 0
                    matchQty = math.min(remainingQty, posQty)
                    pnl = (posPrice - price) * matchQty  // SHORT: (sellPrice - buyPrice) = profit/loss
                    realizedPL += pnl
                    
                    log.info("  Matched SHORT: Sold @" + str.tostring(posPrice, "#.##") + " Bought @" + str.tostring(price, "#.##") + " Qty:" + str.tostring(matchQty, "0") + " P&L:" + str.tostring(pnl, "#.##"))
                    
                    if posQty > matchQty
                        newPos = "sell|" + str.tostring(posQty - matchQty, "0") + "|" + str.tostring(posPrice, "#.##")
                        array.set(posStack, i, newPos)
                        i += 1
                    else
                        array.remove(posStack, i)
                    
                    remainingQty -= matchQty
            else
                break
        
        if remainingQty > 0
            array.push(posStack, "buy|" + str.tostring(remainingQty, "0") + "|" + str.tostring(price, "#.##"))
            log.info("  Added to stack: BUY " + str.tostring(remainingQty, "0") + "@" + str.tostring(price, "#.##"))
    
    else  // SELL
        i = 0
        while remainingQty > 0 and i < array.size(posStack)
            topPos = array.get(posStack, i)
            posType = str.substring(topPos, 0, str.pos(topPos, "|"))
            
            if posType == "buy"
                parts = str.split(topPos, "|")
                posQty = str.tonumber(array.get(parts, 1))
                posPrice = str.tonumber(array.get(parts, 2))
                
                if posQty > 0
                    matchQty = math.min(remainingQty, posQty)
                    pnl = (price - posPrice) * matchQty
                    realizedPL += pnl
                    
                    log.info("  Matched LONG: Bought @" + str.tostring(posPrice, "#.##") + " Sold @" + str.tostring(price, "#.##") + " Qty:" + str.tostring(matchQty, "0") + " P&L:" + str.tostring(pnl, "#.##"))
                    
                    if posQty > matchQty
                        newPos = "buy|" + str.tostring(posQty - matchQty, "0") + "|" + str.tostring(posPrice, "#.##")
                        array.set(posStack, i, newPos)
                        i += 1
                    else
                        array.remove(posStack, i)
                    
                    remainingQty -= matchQty
            else
                break
        
        if remainingQty > 0
            array.push(posStack, "sell|" + str.tostring(remainingQty, "0") + "|" + str.tostring(price, "#.##"))
            log.info("  Added to stack: SELL " + str.tostring(remainingQty, "0") + "@" + str.tostring(price, "#.##"))
    
    log.info("  Realized P&L from this order: " + str.tostring(realizedPL, "#.##") + " | Stack size after: " + str.tostring(array.size(posStack)))
    
    realizedPL

// Convert size string to size object
f_getSize(sizeStr) =>
    sizeStr == "tiny" ? size.tiny : sizeStr == "small" ? size.small : size.normal

// Strip all quotes from a string
f_stripQuotes(inputStr) =>
    result = inputStr
    // Keep replacing until no more quotes
    for j = 0 to 10
        oldLen = str.length(result)
        result := str.replace(result, "\"", "")
        result := str.replace(result, "'", "")
        if str.length(result) == oldLen
            break
    result

// Parse CSV symbol to TradingView format
// Example: NIFTY25NOV25900CE -> NSE:NIFTY251125C25900
// Format: baseSym + date + month + year(25) + typeOP + strike
f_parseCSVSymbol(csvSymbol) =>
    s = str.upper(csvSymbol)
    
    // Find month position (first occurrence of 3-letter month)
    monthPos = str.pos(s, "JAN")
    monthNum = "01"
    
    if na(monthPos)
        monthPos := str.pos(s, "FEB")
        monthNum := "02"
    if na(monthPos)
        monthPos := str.pos(s, "MAR")
        monthNum := "03"
    if na(monthPos)
        monthPos := str.pos(s, "APR")
        monthNum := "04"
    if na(monthPos)
        monthPos := str.pos(s, "MAY")
        monthNum := "05"
    if na(monthPos)
        monthPos := str.pos(s, "JUN")
        monthNum := "06"
    if na(monthPos)
        monthPos := str.pos(s, "JUL")
        monthNum := "07"
    if na(monthPos)
        monthPos := str.pos(s, "AUG")
        monthNum := "08"
    if na(monthPos)
        monthPos := str.pos(s, "SEP")
        monthNum := "09"
    if na(monthPos)
        monthPos := str.pos(s, "OCT")
        monthNum := "10"
    if na(monthPos)
        monthPos := str.pos(s, "NOV")
        monthNum := "11"
    if na(monthPos)
        monthPos := str.pos(s, "DEC")
        monthNum := "12"
    
    // Extract components
    baseSym = str.substring(s, 0, monthPos - 2)           // Everything before date (e.g., NIFTY)
    dateStr = str.substring(s, monthPos - 2, monthPos)    // 2 chars before month = expiry date (e.g., 25)
    strikeAndType = str.substring(s, monthPos + 3)        // Everything after month (e.g., 25900CE)
    
    // Extract option type (CE or PE)
    typeOp = str.contains(strikeAndType, "CE") ? "C" : str.contains(strikeAndType, "PE") ? "P" : ""
    
    // Extract strike (remove CE/PE from end)
    strike = str.replace(str.replace(strikeAndType, "CE", ""), "PE", "")
    
    // Build final symbol: NSE:NIFTY + date + month + year(25) + typeOP + strike
    // Format: NSE:NIFTY251125C25900
    result = "NSE:" + baseSym + dateStr + monthNum + "25" + typeOp + strike
    result

// Parse CSV data once and cache it in maps
f_initializeOrderCache() =>
    if str.length(ordersData) == 0
        true  // Empty data
    else if cacheInitialized and array.size(cachedOrderTimes) > 0
        true  // Already initialized, skip re-parsing
    else
        log.info("Initializing cache...")
        // Clear existing cache
        array.clear(cachedOrderTimes)
        array.clear(cachedOrderSymbols)
        array.clear(cachedOrderTypes)
        array.clear(cachedOrderQuantities)
        array.clear(cachedOrderPrices)
        
        lines = str.split(ordersData, "\n")
        log.info("Parsing " + str.tostring(array.size(lines)) + " lines from CSV")
        
        for i = 0 to math.min(array.size(lines) - 1, 450)
            line = array.get(lines, i)
            if str.length(line) > 0 and not str.contains(line, "Time")  // Skip header
                // Remove quotes and split
                cleanLine = str.replace(line, "\"", "")
                parts = str.split(cleanLine, ",")
                log.info("Line " + str.tostring(i) + ": " + str.tostring(array.size(parts)) + " parts")
                
                if array.size(parts) >= 7
                    orderTimeStr = str.trim(array.get(parts, 0))
                    tradeType = str.lower(str.trim(array.get(parts, 1)))
                    csvSymbol = str.trim(array.get(parts, 2))
                    qtyStr = str.trim(array.get(parts, 4))
                    priceStr = str.trim(array.get(parts, 5))
                    statusStr = str.trim(array.get(parts, 6))
                    
                    // Remove all quotes from status using helper function
                    statusStr := str.lower(f_stripQuotes(statusStr))
                    
                    // Skip orders that are not COMPLETE
                    if statusStr != "complete"
                        log.info("  Skipping - Status: " + statusStr)
                        continue
                    
                    // Remove any quotes from fields
                    orderTimeStr := str.replace(orderTimeStr, "\"", "")
                    tradeType := str.replace(tradeType, "\"", "")
                    csvSymbol := str.replace(csvSymbol, "\"", "")
                    priceStr := str.replace(priceStr, "\"", "")
                    
                    // Extract quantity (format: "525/525" -> take first number)
                    qtyParts = str.split(qtyStr, "/")
                    qtyFirstPart = array.size(qtyParts) > 0 ? str.trim(array.get(qtyParts, 0)) : "0"
                    // Remove any remaining quotes
                    qtyFirstPart := str.replace(qtyFirstPart, "\"", "")
                    qtyFirstPart := str.replace(qtyFirstPart, "'", "")
                    quantity = str.tonumber(qtyFirstPart)
                    price = str.tonumber(priceStr)
                    
                    log.info("  Raw qtyStr: '" + qtyStr + "' | After split: '" + qtyFirstPart + "' | Converted: " + str.tostring(quantity) + " | Symbol: " + csvSymbol + " | Type: " + tradeType + " | Price: " + str.tostring(price) + " | Time: " + orderTimeStr)
                    
                    // Parse order execution time (format: 2025-11-24 15:05:14)
                    orderTimeMs = int(na)
                    if str.length(orderTimeStr) >= 19
                        yVal = int(str.tonumber(str.substring(orderTimeStr, 0, 4)))
                        moVal = int(str.tonumber(str.substring(orderTimeStr, 5, 7)))
                        dVal = int(str.tonumber(str.substring(orderTimeStr, 8, 10)))
                        hVal = int(str.tonumber(str.substring(orderTimeStr, 11, 13)))
                        miVal = int(str.tonumber(str.substring(orderTimeStr, 14, 16)))
                        sVal = int(str.tonumber(str.substring(orderTimeStr, 17, 19)))
                        
                        orderTimeMs := timestamp(yVal, moVal, dVal, hVal, miVal, sVal)
                        log.info("  Parsed timestamp: " + str.tostring(orderTimeMs))
                    
                    // Cache the parsed order data
                    if not na(orderTimeMs) and not na(price) and not na(quantity)
                        // Clean symbol and type one more time before caching
                        cleanSymbol = str.replace(str.replace(f_parseCSVSymbol(csvSymbol), "\"", ""), "'", "")
                        cleanType = str.replace(str.replace(tradeType, "\"", ""), "'", "")
                        
                        array.push(cachedOrderTimes, orderTimeMs)
                        array.push(cachedOrderSymbols, cleanSymbol)
                        array.push(cachedOrderTypes, cleanType)
                        array.push(cachedOrderQuantities, quantity)
                        array.push(cachedOrderPrices, price)
                        log.info("  âœ“ Cached order")
        
        log.info("Cache initialized with " + str.tostring(array.size(cachedOrderTimes)) + " orders")
        
        // Log all cached orders
        if array.size(cachedOrderTimes) > 0
            log.info("=== CACHED ORDERS ===")
            for i = 0 to array.size(cachedOrderTimes) - 1
                orderTime = array.get(cachedOrderTimes, i)
                orderSymbol = array.get(cachedOrderSymbols, i)
                orderType = array.get(cachedOrderTypes, i)
                quantity = array.get(cachedOrderQuantities, i)
                price = array.get(cachedOrderPrices, i)
                log.info("[" + str.tostring(i + 1) + "] " + orderType + " | " + orderSymbol + " | Qty: " + str.tostring(quantity, "0") + " @ " + str.tostring(price, "#.##") + " | Time: " + str.tostring(orderTime))
            log.info("=== END CACHED ORDERS ===")
        true

// Render orders for current bar time from cache
f_renderOrdersFromCache() =>
    barTime = time
    currentSymbol = syminfo.tickerid
    buyOrderCount = 0
    sellOrderCount = 0
    barBuyPL = 0.0
    barSellPL = 0.0
    
    // Only render if cache is populated
    if array.size(cachedOrderTimes) == 0
        [0, 0, 0.0, 0.0]
    else
        // Get first order time for reference
        firstOrderTime = array.get(cachedOrderTimes, 0)
        
        timeMatches = 0
        symbolMatches = 0
        
        // Aggregation arrays for matching orders
        var array<float> buyQtys = array.new<float>()
        var array<float> buyPrices = array.new<float>()
        var array<float> sellQtys = array.new<float>()
        var array<float> sellPrices = array.new<float>()
        
        // Clear aggregation arrays for this bar
        array.clear(buyQtys)
        array.clear(buyPrices)
        array.clear(sellQtys)
        array.clear(sellPrices)
        
        // Only log bars within Â±2 hours of first order time to reduce spam
        logWindowStart = firstOrderTime - (2 * 60 * 60 * 1000)  // 2 hours before
        logWindowEnd = firstOrderTime + (2 * 60 * 60 * 1000)    // 2 hours after
        
        if barTime >= logWindowStart and barTime <= logWindowEnd
            log.info("Bar: " + str.tostring(bar_index) + " | Time: " + str.tostring(barTime) + " | Order Time: " + str.tostring(firstOrderTime))
        
        // Find all orders matching current bar time
        for i = 0 to array.size(cachedOrderTimes) - 1
            orderTime = array.get(cachedOrderTimes, i)
            
            // Round order time to nearest 30-second bar
            // Math.round equivalent: (x + 15000) / 30000 * 30000
            orderTimeRounded = math.round(orderTime / 30000) * 30000
            
            if orderTimeRounded == barTime
                timeMatches += 1
                orderSymbol = array.get(cachedOrderSymbols, i)
                orderType = array.get(cachedOrderTypes, i)
                quantity = array.get(cachedOrderQuantities, i)
                price = array.get(cachedOrderPrices, i)
                
                // Clean symbol and type (remove any stray quotes)
                orderSymbol := str.replace(str.replace(orderSymbol, "\"", ""), "'", "")
                orderType := str.replace(str.replace(orderType, "\"", ""), "'", "")
                
                // Check symbol match
                symbolMatch = str.contains(str.upper(currentSymbol), str.upper(orderSymbol)) or str.contains(str.upper(orderSymbol), str.upper(currentSymbol))
                
                if symbolMatch
                    symbolMatches += 1
                
                // Log ALL cache hits
                if timeMatches == 1  // Log header only once per bar
                    log.info("â± CACHE HIT - Bar Time: " + str.tostring(barTime) + " | Order Time: " + str.tostring(orderTime) + " | Rounded: " + str.tostring(orderTimeRounded) + " | Symbol: " + currentSymbol)
                
                log.info("  Order[" + str.tostring(i) + "]: " + orderSymbol + " | " + orderType + " | " + str.tostring(quantity) + "@" + str.tostring(price) + " | " + (symbolMatch ? "âœ“" : "âœ—"))
                
                if matchSymbol and not symbolMatch
                    continue
                
                isBuy = orderType == "buy"
                isSell = orderType == "sell"
                shouldShow = (isBuy and showBuyOrders) or (isSell and showSellOrders)
                
                if shouldShow
                    // Collect order data for aggregation
                    if isBuy
                        array.push(buyQtys, quantity)
                        array.push(buyPrices, price)
                    else
                        array.push(sellQtys, quantity)
                        array.push(sellPrices, price)
        
        // Render aggregated buy orders
        if array.size(buyQtys) > 0
            totalBuyQty = 0.0
            avgBuyPrice = 0.0
            for j = 0 to array.size(buyQtys) - 1
                totalBuyQty += array.get(buyQtys, j)
                avgBuyPrice += array.get(buyPrices, j)
            avgBuyPrice := avgBuyPrice / array.size(buyPrices)
            
            // Calculate P&L using stack-based matching
            buyPL = f_calculatePLWithStack("buy", totalBuyQty, avgBuyPrice, positionStack)
            barBuyPL := buyPL  // ASSIGN to return variable
            buyPLColor = buyPL >= 0 ? color.green : color.red
            
            textCol = textColorBuy
            labelY = avgBuyPrice
            labelText = "ðŸ”¼ BUY\n" + str.tostring(totalBuyQty, "0") + "@" + str.tostring(avgBuyPrice, "#.##")
            label.new(x=bar_index, y=labelY, text=labelText, 
                      color=color.new(color.green, 30), textcolor=color.white, size=f_getSize(orderSize), 
                      style=label.style_label_center)
            
            // P&L label below BUY order - showing realized P&L from this order
            plText = str.tostring(buyPL, "#.##")
            label.new(x=bar_index, y=low * 0.99, text=plText, 
                      color=color.new(buyPLColor, 50), textcolor=buyPLColor, size=f_getSize(orderSize), 
                      style=label.style_label_center)
            
            buyOrderCount := array.size(buyQtys)
        
        // Render aggregated sell orders
        if array.size(sellQtys) > 0
            totalSellQty = 0.0
            avgSellPrice = 0.0
            for j = 0 to array.size(sellQtys) - 1
                totalSellQty += array.get(sellQtys, j)
                avgSellPrice += array.get(sellPrices, j)
            avgSellPrice := avgSellPrice / array.size(sellPrices)
            
            // Calculate P&L using stack-based matching
            sellPL = f_calculatePLWithStack("sell", totalSellQty, avgSellPrice, positionStack)
            barSellPL := sellPL  // ASSIGN to return variable
            sellPLColor = sellPL >= 0 ? color.green : color.red
            
            textCol = textColorSell
            labelY = avgSellPrice
            labelText = "ðŸ”½ SELL\n" + str.tostring(totalSellQty, "0") + "@" + str.tostring(avgSellPrice, "#.##")
            label.new(x=bar_index, y=labelY, text=labelText, 
                      color=color.new(color.red, 30), textcolor=color.white, size=f_getSize(orderSize), 
                      style=label.style_label_center)
            
            // P&L label below SELL order - showing realized P&L from this order
            plText = str.tostring(sellPL, "#.##")
            label.new(x=bar_index, y=low * 0.99, text=plText, 
                      color=color.new(sellPLColor, 50), textcolor=sellPLColor, size=f_getSize(orderSize), 
                      style=label.style_label_center)
            
            sellOrderCount := array.size(sellQtys)
        
        // Log summary for ALL matches
        if timeMatches > 0
            log.info("  Summary: " + str.tostring(timeMatches) + " time matches | " + str.tostring(symbolMatches) + " symbol matches | BUY: " + str.tostring(buyOrderCount) + " | SELL: " + str.tostring(sellOrderCount))
        
        [buyOrderCount, sellOrderCount, barBuyPL, barSellPL]

// Parse and visualize orders
f_parseAndPlot() =>
    // Render orders from cache for current bar
    f_renderOrdersFromCache()

// Initialize cache on first run only
if not cacheInitialized
    f_initializeOrderCache()
    cacheInitialized := true

// Execute order parsing
[totalBuys, totalSells, barBuyPL, barSellPL] = f_parseAndPlot()

// Update global running P&L
globalRunningPL := globalRunningPL + barBuyPL + barSellPL

// Display RUNNING P&L label ABOVE bars with orders
if barBuyPL != 0 or barSellPL != 0
    runningPLColor = globalRunningPL >= 0 ? color.green : color.red
    label.new(x=bar_index, y=high * 1.03, text="ðŸ“Š RUNNING P&L: " + str.tostring(globalRunningPL, "#.##"), 
              color=color.new(runningPLColor, 15), textcolor=color.white, size=size.large, 
              style=label.style_label_upper_left, xloc=xloc.bar_index, yloc=yloc.price)


